; ==================== ОПРЕДЕЛЕНИЕ СТЕКА ====================
STACKSG     SEGMENT PARA STACK      
; SEGMENT - начало сегмента (блока памяти)
; PARA - выравнивание на границу 16 байт (это просто требование DOS)
; STACK - указываем что это сегмент стека
; STACKSG - просто имя, можем назвать как угодно

    DB 64 DUP(?)                    
; DB - Define Byte (определить байты)
; 64 DUP(?) - создать 64 байта неинициализированной памяти
; DUP - повторить (duplicate)
; (?) - значение не определено (может быть любым)
; ВСЕГО: резервируем 64 байта для стека

STACKSG     ENDS                    
; ENDS - конец сегмента (end segment)
; Теперь сегмент стека определен


; ==================== ОПРЕДЕЛЕНИЕ СЕГМЕНТА ДАННЫХ ====================
DATASG      SEGMENT PARA 'DATA'     
; DATASG - имя сегмента данных (data segment)
; 'DATA' - тип сегмента (для данных)

    MySTR     DB 21, 0, 21 DUP(?)  
; MySTR - буфер для ввода строки с клавиатуры
; Структура буфера DOS для функции 0Ah:
; 1-й байт: 21 - МАКСИМАЛЬНАЯ длина строки (сколько символов МОЖЕТ принять)
; 2-й байт: 0 - ФАКТИЧЕСКАЯ длина строки (сколько символов ВВЕЛИ, заполнит DOS)
; 3-й..23-й байты: 21 DUP(?) - место для хранения самой строки

    MSG1      DB 'Enter the string: ', '$'  
; MSG1 - сообщение "Введите строку: "
; DB - определяем последовательность байтов (символов)
; '$' - специальный символ-маркер КОНЦА строки для функции DOS 09h

    MSG2      DB 0Dh, 0Ah, 'Result: ', 0Dh, 0Ah, '$'  
; MSG2 - сообщение для вывода результата
; 0Dh - код возврата каретки (курсор в начало строки)
; 0Ah - код перевода строки (курсор на строку ниже)
; ВСЕГО: перевод строки + "Result: " + перевод строки

    SPACE     DB ' $'               
; SPACE - строка содержащая пробел
; Нужна для разделения HEX-чисел при выводе

DATASG      ENDS                    
; Конец сегмента данных


; ==================== ОПРЕДЕЛЕНИЕ СЕГМЕНТА КОДА ====================
CODESG      SEGMENT PARA 'CODE'     
; CODESG - сегмент кода (code segment)
; 'CODE' - тип сегмента (для кода программы)

    ASSUME  CS:CODESG, DS:DATASG, SS:STACKSG  
; ASSUME - говорит ассемблеру: "предполагай что:"
; CS (Code Segment) будет указывать на CODESG
; DS (Data Segment) будет указывать на DATASG  
; SS (Stack Segment) будет указывать на STACKSG
; ЭТО НЕ УСТАНАВЛИВАЕТ РЕГИСТРЫ! Просто помогает ассемблеру


; ==================== ГЛАВНАЯ ПРОЦЕДУРА ПРОГРАММЫ ====================
ENTRY   PROC FAR                    
; ENTRY - имя процедуры (точка входа в программу)
; PROC - начало процедуры (procedure)
; FAR - дальняя процедура (для COM-файлов)

        ; === ИНИЦИАЛИЗАЦИЯ СЕГМЕНТНЫХ РЕГИСТРОВ ===
        PUSH DS                     
; PUSH - положить значение в стек (как положить бумажку в стопку)
; DS - регистр Data Segment (указывает на данные)
; Сохраняем текущее значение DS, потому что DOS его использует

        SUB AX, AX                  
; SUB - вычитание (subtract)
; SUB AX, AX означает: AX = AX - AX
; Результат: AX = 0 (быстрый способ обнулить регистр)

        PUSH AX                     
; Кладем 0 в стек (для механизма возврата в DOS)

        MOV AX, DATASG              
; MOV - пересылка данных (move)
; DATASG - адрес сегмента данных
; Загружаем адрес сегмента данных в AX
; Нельзя писать MOV DS, DATASG напрямую!

        MOV DS, AX                  
; Теперь копируем из AX в DS
; Теперь DS указывает на НАШИ данные

        
        ; === ВЫВОД ПРИГЛАШЕНИЯ "Enter the string: " ===
        MOV AH, 09h                 
; AH - старший байт регистра AX
; 09h - номер функции DOS: "Вывод строки"
; В DOS через прерывания: номер функции в AH, параметры в других регистрах

        LEA DX, MSG1                
; LEA - Load Effective Address (загрузить эффективный адрес)
; DX - регистр Data (используется для адресов)
; MSG1 - наша строка с приглашением
; Результат: в DX теперь адрес строки "Enter the string: "

        INT 21h                     
; INT - вызов прерывания (interrupt)
; 21h - прерывание DOS (основные функции ввода-вывода)
; Выполняет функцию из AH (09h) с параметром из DX
; На экране появляется: "Enter the string: "

        
        ; === ВВОД СТРОКИ С КЛАВИАТУРЫ ===
        MOV AH, 0Ah                 
; 0Ah - номер функции DOS: "Буферизованный ввод строки"

        LEA DX, MySTR               
; В DX загружаем адрес нашего буфера MySTR
; DOS будет знать куда сохранять введенную строку

        INT 21h                     
; Вызываем прерывание - ждем пока пользователь введет строку и нажмет Enter
; DOS сохранит строку в MySTR и запишет длину во второй байт

        
        ; === ПРОВЕРКА ДЛИНЫ ВВЕДЕННОЙ СТРОКИ ===
        MOV BL, MySTR+1             
; BL - младший байт регистра BX
; MySTR+1 - второй байт буфера (фактическая длина строки)
; Копируем длину строки в BL

        CMP BL, 20                  
; CMP - сравнение (compare)
; Сравниваем BL с числом 20
; Если пользователь ввел меньше 20 символов - ошибка

        JB  Exit                    
; JB - Jump if Below (перейти если меньше)
; Если BL < 20, переходим на метку Exit (завершаем программу)
; Иначе продолжаем выполнение

        
        ; === ВЫВОД ЗАГОЛОВКА "Result: " ===
        MOV AH, 09h                 
; Снова функция вывода строки

        LEA DX, MSG2                
; Адрес сообщения "Result: " с переводами строк

        INT 21h                     
; Выводим на экран:
; (перевод строки)
; "Result: "
; (перевод строки)

        
        ; === НАСТРОЙКА ДЛЯ ОБРАБОТКИ СИМВОЛОВ ===
        LEA SI, MySTR+2             
; SI - Source Index (регистр-указатель источника)
; MySTR+2 - третий байт буфера (начало самой строки, пропускаем байты длины)
; В SI теперь адрес ПЕРВОГО символа строки

        ADD SI, 4                   
; ADD - сложение (add)
; SI = SI + 4 - перемещаемся к 5-му символу
; Почему 5-й? Индексация с 0:
; SI+0 = 1-й символ
; SI+1 = 2-й символ
; SI+2 = 3-й символ  
; SI+3 = 4-й символ
; SI+4 = 5-й символ

        MOV CX, 7                   
; CX - Count register (регистр-счетчик)
; Устанавливаем CX = 7 - будем обрабатывать 7 символов:
; 5-й, 7-й, 9-й, 11-й, 13-й, 15-й, 17-й (через один)

        
; ==================== ОСНОВНОЙ ЦИКЛ ОБРАБОТКИ ====================
ProcessLoop:
; Метка - сюда будем возвращаться в цикле

        ; === БЕРЕМ ТЕКУЩИЙ СИМВОЛ ===
        MOV AL, [SI]                
; [SI] - обращение к памяти по адресу в SI (как *pointer в C)
; AL - младший байт AX (8 бит)
; Копируем текущий символ строки в AL

        CALL PrintHex               
; CALL - вызов процедуры (как вызов функции)
; PrintHex - наша процедура для вывода символа в HEX
; Управление переходит к процедуре, потом вернется сюда

        
        ; === ВЫВОД ПРОБЕЛА МЕЖДУ ЧИСЛАМИ ===
        PUSH AX                     
; Сохраняем AX в стек (чтобы не потерять текущий символ)

        MOV AH, 09h                 
; Функция вывода строки

        LEA DX, SPACE               
; Адрес строки с пробелом

        INT 21h                     
; Выводим пробел на экран

        POP AX                      
; POP - достать из стека (обратно PUSH)
; Восстанавливаем AX (наш символ)

        
        ; === ПЕРЕХОД К СЛЕДУЮЩЕМУ СИМВОЛУ (ЧЕРЕЗ ОДИН) ===
        ADD SI, 2                   
; SI = SI + 2 - перепрыгиваем через один символ
; Было: SI указывает на 5-й символ
; Стало: SI указывает на 7-й символ

        LOOP ProcessLoop            
; LOOP - команда цикла:
; 1. CX = CX - 1 (уменьшаем счетчик)
; 2. Если CX ≠ 0, перейти на метку ProcessLoop
; 3. Если CX = 0, продолжать дальше
; Цикл выполнится 7 раз (CX от 7 до 0)

        
; ==================== ЗАВЕРШЕНИЕ ПРОГРАММЫ ====================
Exit:
; Метка выхода из программы

        MOV AH, 4Ch                 
; 4Ch - функция DOS "Завершение программы"

        INT 21h                     
; Вызываем прерывание - программа завершается
; Управление возвращается в DOS

        RET                         
; RET - возврат из процедуры (return)
; Для FAR процедуры это дальний возврат

ENTRY   ENDP                        
; ENDP - конец процедуры (end procedure)


; ==================== ПРОЦЕДУРА ВЫВОДА В HEX ====================
PrintHex PROC
; Процедура выводит байт из AL в виде двух HEX-цифр
; Например: AL = 45h → выведет "45"

        ; === СОХРАНЯЕМ РЕГИСТРЫ ЧТОБЫ НЕ ИСПОРТИТЬ ===
        PUSH CX                     ; Сохраняем CX (счетчик цикла)
        PUSH AX                     ; Сохраняем AX (наш символ)

        
        ; === ВЫВОД СТАРШЕЙ ПОЛОВИНЫ (ПЕРВАЯ ЦИФРА) ===
        MOV CL, 4                   ; CL = 4 (будем сдвигать на 4 бита)
        SHR AL, CL                  ; Сдвиг вправо на 4 бита
        ; SHR (Shift Right) - сдвигает биты вправо, слева добавляет нули
        ; Пример: AL = 45h (01000101) → после SHR: AL = 04h (00000100)
        ; Теперь в AL старшая тетрада (4 бита) нашего символа

        CALL PrintDigit             ; Выводим эту цифру (04h → '4')

        
        ; === ВЫВОД МЛАДШЕЙ ПОЛОВИНЫ (ВТОРАЯ ЦИФРА) ===
        POP AX                      ; Достаем исходный символ из стека
        PUSH AX                     ; И снова сохраняем (для восстановления)
        
        AND AL, 0Fh                 ; Применяем маску 00001111
        ; AND - побитовое И: 0 AND x = 0, 1 AND x = x
        ; Пример: AL = 45h (01000101) AND 0Fh (00001111) = 05h (00000101)
        ; Теперь в AL младшая тетрада нашего символа

        CALL PrintDigit             ; Выводим эту цифру (05h → '5')

        
        ; === ВОССТАНАВЛИВАЕМ РЕГИСТРЫ ===
        POP AX                      ; Восстанавливаем AX
        POP CX                      ; Восстанавливаем CX
        
        RET                         ; Возврат из процедуры
PrintHex ENDP


; ==================== ПРОЦЕДУРА ВЫВОДА ОДНОЙ HEX-ЦИФРЫ ====================
PrintDigit PROC
; Процедура выводит одну HEX-цифру из AL
; AL должен содержать число от 0 до 15

        CMP AL, 9                   ; Сравниваем AL с 9
        JLE IsDigit                 ; Если AL <= 9, переходим к цифрам

        ; === ЕСЛИ ЧИСЛО 10-15 (A-F) ===
        ADD AL, 'A' - 10            ; Преобразуем в букву
        ; 'A' - это 41h (65 decimal)
        ; 'A' - 10 = 41h - 10 = 37h (55 decimal)
        ; Пример: AL = 10 (Ah) → 10 + 37h = 41h = 'A'
        ;         AL = 11 (Bh) → 11 + 37h = 42h = 'B'
        JMP PrintChar               ; Переходим к выводу

IsDigit:
        ; === ЕСЛИ ЧИСЛО 0-9 ===
        ADD AL, '0'                 ; Преобразуем в цифру
        ; '0' - это 30h (48 decimal)
        ; Пример: AL = 5 → 5 + 30h = 35h = '5'

PrintChar:
        ; === ВЫВОД СИМВОЛА НА ЭКРАН ===
        MOV DL, AL                  ; Копируем символ в DL
        MOV AH, 02h                 ; Функция DOS "Вывод символа"
        INT 21h                     ; Выводим символ из DL
        
        RET                         ; Возврат из процедуры
PrintDigit ENDP


CODESG ENDS                         ; Конец сегмента кода
END ENTRY                           ; Конец программы, начинать с ENTRY