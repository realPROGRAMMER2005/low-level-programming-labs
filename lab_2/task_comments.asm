; ==================== ОПРЕДЕЛЕНИЕ СТЕКА ====================
STACKSG     SEGMENT PARA STACK      
; Начало сегмента стека с выравниванием на границу параграфа (16 байт)

    DB 64 DUP(?)                    
; Резервируем 64 байта неинициализированной памяти для стека
; DUP(?) означает "повторить 64 раза байт с неопределенным значением"

STACKSG     ENDS                    
; Конец сегмента стека


; ==================== ОПРЕДЕЛЕНИЕ СЕГМЕНТА ДАННЫХ ====================
DATASG      SEGMENT PARA 'DATA'     
; Начало сегмента данных

    MySTR     DB 21, 0, 21 DUP(?)  
; Буфер для ввода строки с клавиатуры
; Структура буфера для функции DOS 0Ah:
; 1-й байт: 21 - максимальная длина вводимой строки
; 2-й байт: 0 - будет содержать фактическую длину введенной строки
; 3-й..23-й байты: место для хранения самой строки

    MSG1      DB 'Enter the string: ', '$'  
; Сообщение-приглашение для ввода строки
; '$' - маркер конца строки для функции DOS 09h

    MSG2      DB 0Dh, 0Ah, 'Result: ', 0Dh, 0Ah, '$'  
; Сообщение для вывода результата
; 0Dh - возврат каретки (курсор в начало строки)
; 0Ah - перевод строки (курсор на строку ниже)

    CHAR_MSG  DB ' - $'             
; Разделитель между символом и его HEX-представлением

    NEWLINE   DB 0Dh, 0Ah, '$'      
; Строка для перевода на новую строку

DATASG      ENDS                    
; Конец сегмента данных


; ==================== ОПРЕДЕЛЕНИЕ СЕГМЕНТА КОДА ====================
CODESG      SEGMENT PARA 'CODE'     
; Начало сегмента кода

    ASSUME  CS:CODESG, DS:DATASG, SS:STACKSG  
; Указание ассемблеру на соответствие сегментных регистров:
; CS (Code Segment) будет указывать на CODESG
; DS (Data Segment) будет указывать на DATASG
; SS (Stack Segment) будет указывать на STACKSG


; ==================== ГЛАВНАЯ ПРОЦЕДУРА ПРОГРАММЫ ====================
ENTRY   PROC FAR                    
; Объявление дальней процедуры - точки входа в программу

        ; === ИНИЦИАЛИЗАЦИЯ СЕГМЕНТНЫХ РЕГИСТРОВ ===
        PUSH DS                     
; Сохраняем текущее значение DS в стек (для совместимости с DOS)

        SUB AX, AX                  
; Обнуляем регистр AX: AX = AX - AX = 0

        PUSH AX                     
; Кладем 0 в стек (для механизма возврата в DOS)

        MOV AX, DATASG              
; Загружаем сегментный адрес данных в AX

        MOV DS, AX                  
; Устанавливаем DS = AX, теперь DS указывает на наш сегмент данных

        
        ; === ВЫВОД ПРИГЛАШЕНИЯ ДЛЯ ВВОДА СТРОКИ ===
        MOV AH, 09h                 
; Устанавливаем AH = 09h - функция DOS для вывода строки

        LEA DX, MSG1                
; Загружаем в DX адрес строки MSG1 ("Enter the string: ")

        INT 21h                     
; Вызываем прерывание DOS 21h - выводим приглашение на экран

        
        ; === ВВОД СТРОКИ С КЛАВИАТУРЫ ===
        MOV AH, 0Ah                 
; Устанавливаем AH = 0Ah - функция DOS для буферизованного ввода строки

        LEA DX, MySTR               
; Загружаем в DX адрес буфера MySTR

        INT 21h                     
; Вызываем прерывание DOS - ожидаем ввод строки от пользователя
; DOS сохранит введенную строку в буфер MySTR

        
        ; === ПРОВЕРКА ДЛИНЫ ВВЕДЕННОЙ СТРОКИ ===
        MOV BL, MySTR+1             
; Загружаем в BL второй байт буфера (фактическую длину строки)

        CMP BL, 20                  
; Сравниваем длину строки с 20 (минимально требуемая длина)

        JB  Exit                    
; Если длина меньше 20 (Jump Below), переходим к завершению программы

        
        ; === ВЫВОД ЗАГОЛОВКА РЕЗУЛЬТАТА ===
        MOV AH, 09h                 
; Функция вывода строки

        LEA DX, MSG2                
; Адрес сообщения "Result: " с переводами строк

        INT 21h                     
; Выводим заголовок результата на экран

        
        ; === НАСТРОЙКА ПАРАМЕТРОВ ОБРАБОТКИ СИМВОЛОВ ===
        LEA SI, MySTR+2             
; Загружаем в SI адрес начала данных строки (пропускаем байты длины)

        ADD SI, 4                   
; Перемещаемся к 5-му символу строки (индексация с 0)

        MOV CX, 7                   
; Устанавливаем счетчик цикла = 7 (обработаем 7 символов: 5,7,9,11,13,15,17)

        
; ==================== ОСНОВНОЙ ЦИКЛ ОБРАБОТКИ СИМВОЛОВ ====================
ProcessLoop:
; Метка начала цикла обработки

        ; === ПОЛУЧАЕМ ТЕКУЩИЙ СИМВОЛ ===
        MOV AL, [SI]                
; Загружаем в AL символ из строки по адресу [SI]

        
        ; === ВЫВОД САМОГО СИМВОЛА ===
        MOV DL, AL                  
; Копируем символ из AL в DL (для функции вывода символа)

        MOV AH, 02h                 
; Устанавливаем AH = 02h - функция DOS для вывода символа

        INT 21h                     
; Выводим текущий символ на экран

        
        ; === ВЫВОД РАЗДЕЛИТЕЛЯ " - " ===
        PUSH AX                     
; Сохраняем AX в стек (чтобы не потерять текущий символ)

        MOV AH, 09h                 
; Функция вывода строки

        LEA DX, CHAR_MSG            
; Адрес строки-разделителя " - "

        INT 21h                     
; Выводим разделитель на экран

        POP AX                      
; Восстанавливаем AX из стека

        
        ; === ВЫВОД HEX-ПРЕДСТАВЛЕНИЯ СИМВОЛА ===
        CALL PrintHex               
; Вызываем процедуру для вывода символа в шестнадцатеричном формате

        
        ; === ВЫВОД ПЕРЕВОДА СТРОКИ ===
        PUSH AX                     
; Сохраняем AX в стек

        MOV AH, 09h                 
; Функция вывода строки

        LEA DX, NEWLINE             
; Адрес строки с переводом строки

        INT 21h                     
; Переходим на новую строку

        POP AX                      
; Восстанавливаем AX из стека

        
        ; === ПЕРЕХОД К СЛЕДУЮЩЕМУ СИМВОЛУ (ЧЕРЕЗ ОДИН) ===
        ADD SI, 2                   
; Увеличиваем SI на 2 (переходим через один символ)

        LOOP ProcessLoop            
; Уменьшаем CX на 1 и если CX ≠ 0, переходим к ProcessLoop
; Цикл выполнится 7 раз

        
; ==================== ЗАВЕРШЕНИЕ ПРОГРАММЫ ====================
Exit:
; Метка выхода из программы

        MOV AH, 4Ch                 
; Устанавливаем AH = 4Ch - функция DOS для завершения программы

        INT 21h                     
; Завершаем программу и возвращаем управление в DOS

        RET                         
; Возврат из процедуры

ENTRY   ENDP                        
; Конец главной процедуры


; ==================== ПРОЦЕДУРА ВЫВОДА В HEX-ФОРМАТЕ ====================
PrintHex PROC
; Процедура выводит байт из AL в виде двух шестнадцатеричных цифр

        PUSH CX                     
; Сохраняем CX в стек (чтобы не испортить значение счетчика)

        PUSH AX                     
; Сохраняем AX в стек (исходное значение символа)

        
        ; === ОБРАБОТКА СТАРШЕЙ ТЕТРАДЫ (ПЕРВАЯ ЦИФРА) ===
        MOV CL, 4                   
; Загружаем в CL число 4 (количество бит для сдвига)

        SHR AL, CL                  
; Логический сдвиг AL вправо на 4 бита
; Старшая тетрада (4 бита) перемещается в младшие 4 бита AL

        CALL PrintDigit             
; Вызываем процедуру для вывода старшей тетрады

        
        ; === ОБРАБОТКА МЛАДШЕЙ ТЕТРАДЫ (ВТОРАЯ ЦИФРА) ===
        POP AX                      
; Восстанавливаем исходное значение символа из стека

        PUSH AX                     
; Снова сохраняем AX (для последующего восстановления)

        AND AL, 0Fh                 
; Применяем битовую маску 00001111b
; Оставляем только младшие 4 бита (младшую тетраду)

        CALL PrintDigit             
; Вызываем процедуру для вывода младшей тетрады

        
        ; === ВОССТАНОВЛЕНИЕ РЕГИСТРОВ ===
        POP AX                      
; Восстанавливаем AX из стека

        POP CX                      
; Восстанавливаем CX из стека

        RET                         
; Возврат из процедуры

PrintHex ENDP                       
; Конец процедуры PrintHex


; ==================== ПРОЦЕДУРА ВЫВОДА ОДНОЙ HEX-ЦИФРЫ ====================
PrintDigit PROC
; Процедура выводит одну шестнадцатеричную цифру из AL
; AL должен содержать число от 0 до 15

        CMP AL, 9                   
; Сравниваем значение в AL с 9

        JLE IsDigit                 
; Если AL <= 9, переходим к обработке цифры 0-9

        
        ; === ПРЕОБРАЗОВАНИЕ ДЛЯ БУКВ A-F (10-15) ===
        ADD AL, 'A' - 10            
; Преобразуем число 10-15 в символы 'A'-'F'
; 'A' - 10 = 37h, поэтому:
; 10 + 37h = 41h = 'A'
; 11 + 37h = 42h = 'B'
; ...
; 15 + 37h = 46h = 'F'

        JMP PrintChar               
; Переходим к выводу символа

        
IsDigit:
        ; === ПРЕОБРАЗОВАНИЕ ДЛЯ ЦИФР 0-9 ===
        ADD AL, '0'                 
; Преобразуем число 0-9 в символы '0'-'9'
; '0' = 30h, поэтому:
; 0 + 30h = 30h = '0'
; 1 + 30h = 31h = '1'
; ...
; 9 + 30h = 39h = '9'

        
PrintChar:
        ; === ВЫВОД СИМВОЛА НА ЭКРАН ===
        MOV DL, AL                  
; Копируем символ из AL в DL

        MOV AH, 02h                 
; Устанавливаем AH = 02h - функция DOS для вывода символа

        INT 21h                     
; Выводим символ на экран

        RET                         
; Возврат из процедуры

PrintDigit ENDP                     
; Конец процедуры PrintDigit


CODESG ENDS                         
; Конец сегмента кода

END ENTRY                           
; Конец программы, точка входа - ENTRY